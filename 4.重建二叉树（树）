'''
题目：
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

'''
前序遍历：根结点 ---> 左子树 ---> 右子树
中序遍历：左子树---> 根结点 ---> 右子树
后序遍历：左子树 ---> 右子树 ---> 根结点
层次遍历：只需按层次遍历即可



例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
在二叉树的前序遍历序列中，第一个数字总是树的根结点的值。但在中序遍历序列中，根结点的值在序列的中间（1左边的是左边的树，右边的是右边的树），左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。因此我们需要扫描中序遍历序列，才能找到根结点的值。

前序遍历序列的第一个数字1就是根结点的值。扫描中序遍历序列，就能确定根结点的值的位置。根据中序遍历特点，在根结点的值1前面的3个数字都是左子树结点的值，位于1后面的数字都是右子树结点的值。

　　在二叉树的前序遍历和中序遍历的序列中确定根结点的值、左子树结点的值和右子树结点的值的步骤如下图所示：


分别找到了左、右子树的前序遍历序列和中序遍历序列，我们就可以用同样的方法分别去构建左右子树。换句话说，这是一个递归的过程。

# -*- coding:utf-8 -*-
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    # 返回构造的TreeNode根节点
    def reConstructBinaryTree(self, pre, tin):   #pre是前序遍历，tin是中序遍历
        # write code here
        if not pre or not tin:
            return None
        root = TreeNode(pre[0])     #前序序列的第一个肯定是当前子树的根节点
        val = tin.index(pre[0])       #通过根节点在中序序列中的位置划分出左右子树包含的节点
pre[0]也就是1，在tin中的index

        root.left = self.reConstructBinaryTree(pre[1:val + 1], tin[:val])
#[1:val + 1]表示第一个元素到val+1的切片（不含val+1）
        root.right = self.reConstructBinaryTree(pre[val + 1:], tin[val + 1:])
#[val+1：]表示第val+1到最后一个元素的切片（含最后）
        return root
